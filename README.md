**Binary Representation**
- Convert between denary (decimal) and binary (with fractional parts), and format normalised floating‑point representations using custom mantissa/exponent bit widths.

**Features**
- Denary → Binary (integers and fractions)
- Binary → Denary (integers and fractions)
- Normalise to mantissa/exponent with fixed bit widths
- Shows truncation error when mantissa overflows

**Run**
- Interactive menu: `python3 "Binary representation.py"`

**Conventions**
- Negative integers use minimal‑width two’s complement (e.g., `-5 → 1011`, `-10 → 10110`).
- Positive integers omit a sign bit (e.g., `5 → 0101`).
- Fractions are generated by repeated ×2; for negative decimals the fraction is `(1 − f)` with a 1 borrowed from the integer part.
- Normalisation outputs `mantissa | exponent` with mantissa padded/truncated to the requested bits and exponent in two’s complement.

**Examples**
- Denary → Binary: `5 → 0101`, `10.25 → 01010.01`, `-5.5 → 1010.1`
- Binary → Denary: `0101 → 5`, `01010.01 → 10.25`, `1011 → -5`
- Normalise (mantissa=8, exponent=4): `5 → mantissa 0.1010000, exponent 0011`, general form `0.625*2^3`

**Notes**
- Non‑terminating fractions (e.g., 0.1) are not rounded/capped.
- Binary input interpretation: a leading `1` in the integer part is treated as negative two’s complement for that input width. For unsigned interpretation, prefix a `0` (e.g., `0101`).
- The filename has a space; use quotes when running: `python3 "Binary representation.py"`.
